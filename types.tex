\documentclass{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\title{Type inference rules for CHP}

\begin{document}

\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}
\newcommand{\intersection}{\cap}
\newcommand{\thickbar}{\talloblong}

\maketitle

\section{Booleans}
\begin{mathpar}
\inferrule* [left=True]
    { }
    {\top : \emptyset}

\inferrule* [left=False]
    { }
    {\bot : \emptyset}

\inferrule* [left=Read]
    { }
    {a : \{a\}}

\inferrule* [left=Not]
    {b : r}
    {\lnot b : r}

\inferrule* [left=And]
    {b_1 : r_1 \\ b_2 : r_2}
    {b_1 \land b_2 : r_1 \union r_2}

\inferrule* [left=Or]
    {b_1 : r_1 \\ b_2 : r_2}
    {b_1 \lor b_2 : r_1 \union r_2}
\end{mathpar}

Booleans' types are a single set of variable names from which they read.  All
booleans are well-typed; we say that a boolean $b$ is of type $r$ if the set of
free variables in $b$ is $r$.  $r$ is a worst-case set of variables; we make no
attempt to determine if a particular expression is independent of a particular
variable.  For example, $a \lor \lnot a$ will evaluate to $\top$ regardless of
$a$'s value, but we still give it the type $\{a\}$.

\section{Programs}
\begin{mathpar}
\inferrule* [left=Skip]
    { }
    {skip : (\emptyset, \emptyset)}

\inferrule* [left=Write]
    {b : r}
    {a := b : (r, \{a\})}

\inferrule* [left=Sequence]
    {p_1:(r_1, w_1) \\ p_2:(r_2, w_2)}
    {p_1; p_2 : (r_1 \union (r_2 \setminus w_1), w_1 \union w_2)}

\inferrule* [left=Parallel]
    {p_1:(r_1, w_1) \\ p_2:(r_2, w_2) \\ w_1 \intersection w_2 = \emptyset}
    {p_1 || p_2 :
        ((r_1 \union r_2) \setminus (w_1 \union w_2), w_1 \union w_2)}

\inferrule* [left=Selection]
    {b_1 : q_1, \ldots, b_n : q_n \\
     p_1 : (r_1, w_1), \ldots, p_n : (r_n, w_n)}
    {[b_1 \rightarrow p_1  | \ldots | b_n \rightarrow p_n] : 
     (\Union_{i=1}^{n} (q_i \union r_i), \Union_{i=1}^{n} w_i)}

\inferrule* [left=Repetition]
    {s : (r,w)}
    {\ast s : (r,w)}
\end{mathpar}

Let $p$ range over programs, and $s$ range over both deterministic and
non-deterministic selection statements.

We say that a program $p$ is of type $(r, w)$ if the set of variables that $p$
may read from that cannot be defined before its execution is $r$, and the set of
variables that $p$ may write to is $w$.  A program is well-typed if it has a
type.  We want to enforce the property that no process running in parallel with
$p$ can write to a variable that $p$ may write to.  This is important because,
in hardware, concurrent writes connect voltage to ground through the variable:
the circuit may literally catch fire.

The third requirement of the \textsc{Parallel} rule enforces this; if the write
sets of both parallel programs do not overlap, then they cannot write to the
same variables, and we will not have short circuits.

Similar to how we take the worst-case interpretation of booleans, we take the
worst-case interpretation of multiple paths of execution.  For example, the
program $[\top \rightarrow skip \thickbar \bot \rightarrow a := c]$ will never
read from c or write to a, but is of type $(\{c\}, \{a\})$.  While this
interpretation is unfortunate, without it, because CHP is Turing complete, the
halting problem could be embedded in our type system.

\end{document}
