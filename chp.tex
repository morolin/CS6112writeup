
\documentclass[times,10pt]{article}

\usepackage{times}
\usepackage{epsf}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{color}

\def\Skip{\hbox{\bf skip}}
\def\Else{\hbox{\bf else}}
\def\mod{\hbox{\bf mod}}
\def\true{\hbox{\bf true}}
\def\false{\hbox{\bf false}}
\let\prsarrow = \mapsto

\begin{document}

\begin{center}
\Large Language Specification for CHP and Friends
\end{center}

\section{CHP}

CHP is the highest-level language.  Seen here is CHP with boolean support only.

\subsection{Grammar}

\begin{align*}
    \ell & ::= \top \; | \perp \\
    \mathrm{b} & ::= a \; | \; \ell \; | \; \overline{A?} \; | \; \overline{A!} \; | \; \widehat{A} \; | \; \mathrm{b}_1 \wedge \mathrm{b}_2 \; | \; \mathrm{b}_1 \vee \mathrm{b}_2 \; | \; \lnot \mathrm{b} \; | \; (\mathrm{b})\\
    \mathrm{P} & ::= a := \mathrm{b} \; | \; S \; | \; C \; | \; P_1; P_2 \; | \: P_1 || P_2 \; | \; \mathtt{skip} \; | N | \; (P)\\
    \mathrm{S} & ::= [ \mathrm{b}_1 \rightarrow P_1 \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] \; | \; [ \mathrm{b}_1 \rightarrow P_1 | \; ... \; | \mathrm{b}_n \rightarrow P_n ] \\
        & \qquad | *[ \mathrm{b}_1 \rightarrow P_1 \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] \; | *[ \mathrm{b}_1 \rightarrow P_1 | \; ... \; | \mathrm{b}_n \rightarrow P_n ] \\
    \mathrm{C} & ::= A!\mathrm{b} \; | \; A?a \; | \; C_1 \bullet C_2 \; | \; \underline{C} \\
    \mathrm{N} & ::= \mathtt{new} \; a \; P \; | \; \mathtt{NEW} \; A \; P \; | \; \underline{N}
\end{align*}

Above, we are using $a ... z$ to range over variables, and $A ... Z$ to range over channels.

Additionally, there is some well-accepted syntactic sugar:

$L?$ or $R!$ are dataless channels.  They are equivalent to receiving into a new variable, and sending an arbitrary value, respectively.

$*[S]$ is syntactic sugar for $*[ \top \; \rightarrow \; S]$, which is used for infinite loops. 

$[\textrm{b}]$ is used to mean $[\textrm{b} \; \rightarrow \mathtt{skip}]$, which means that we wait for a boolean expression to be true before continuing.

In addition, nothing that is underlined is valid in the definition of a program; these are all intermediate expressions that can only arise during program execution.

\subsection{Environment Variables and Notation}
Here we use $\xi$ as a metasyntactic variable for the elements of $\sigma$.
\begin{align*}
    \text{Set Definitions} & ::= \mathbb{B} \; | \; \mathbb{V} \; | \; \mathbb{C} \; | \; \Sigma \; | \; \Omega \\
    \text{Environment Variables} & ::= \sigma, \varsigma, \varsigma_r, \varsigma_w, \rho, \rho_r, \rho_w, \omega \\
    \text{Environment Variable Ops} & ::= \oslash_\xi, \odot, \oplus, \oplus_a, \ominus, \triangleleft, \diamond, \triangleright, +, -
\end{align*}

The set definitions are:
\begin{enumerate}
    \item $\mathbb{B} = \{\top; \bot\}$ is the set of booleans.
    \item $\mathbb{V} = \{a; \ldots; z\}$ is the set of variables.
    \item $\mathbb{C} = \{A; \ldots; Z\}$ is the set of channels.
    \item $\Sigma = \{\sigma\}$ is the set of all environments.
    \item $\Omega = \{\omega\}$ is the set of all stacks.
\end{enumerate}

The environment variable definitions are:
\begin{enumerate}
    \item $\sigma = \{\varsigma, \varsigma_r, \varsigma_w, \rho, \rho_r, \rho_w, \omega\}$ is simply the symbol that represents the entire environment. We will use e.g. $\sigma[\varsigma]$ to refer to the $\varsigma$ contained inside $\sigma$.
    \item $\varsigma \subseteq \mathbb{V} \times \mathbb{B}$ is the map from in-scope variables to their boolean values.
    \item $\varsigma_r \subseteq \mathbb{V}$ is the set of variables that the program currently has read access to.
    \item $\varsigma_w \subseteq \mathbb{V}$ is the set of variables that the program currently has write access to.
    \item $\rho \subseteq \mathbb{C}$ is the set of in-scope channels.
    \item $\rho_r \subseteq \mathbb{C}$ is the multiset of channels currently being read from (is a set if channels are end-to-end).
    \item $\rho_w \subseteq \mathbb{C} \times \mathbb{B}$ is the multimap from channels currently being written to to the booleans being sent on them (is a map if channels are end-to-end).
    \item $\omega \in (\Sigma + (\Omega \times \Omega))^*$ is the stack of environments/double stacks, used for handling scoping.
\end{enumerate}

The environment variable operation definitions are:
\begin{enumerate}
    \item $\sigma \oslash_\xi \xi'$ is defined to be $\sigma$ with $\xi$ replaced with $\xi'$ (e.g. $\sigma \oslash_\varsigma \varnothing = \{\varnothing, \sigma[\varsigma_r], \sigma[\varsigma_w], \sigma[\rho_r], \sigma[\rho_w]\}$).
    \item $\sigma \odot a$ is defined to be $\sigma \oslash_\varsigma (\{(a', \ell) \; | \; (a', \ell) \in \sigma[\varsigma] \wedge a' \neq a\}) \oslash_{\varsigma_r} (\sigma[\varsigma_r] \cup \{a\}) \oslash_{\varsigma_w} (\sigma[\varsigma_w] \cup \{a\})$.
        In other words, this is $\sigma$ with $a$ added to both $\varsigma_r$ and $\varsigma_w$ (assuming it wasn't already there) and any binding for $a$ removed from $\varsigma$.
    \item $\sigma \odot A$ is defined to be $\sigma \oslash_\rho (\sigma[\rho] \cup \{A\}) \oslash_{\rho_r} (\{A' \; | \; A' \in \sigma[\rho_r] \wedge A' \neq A\}) \oslash_{\rho_w} (\{(A', \ell) \; | \; (A', \ell) \in \sigma[\rho_w] \wedge A' \neq A\})$.
        In other words, this is $\sigma$ with $A$ added to $\rho$ (assuming it wasn't already there) and any sends and receives currently in progress for $A$ removed from $\rho_w$ and $\rho_r$, respectively.
    \item $\varsigma \oplus \varsigma'$ is defined to be $\{(a, \ell) \; | \; (a, \ell) \in \varsigma'\} \cup \{(a, \ell) \; | \; (a, \ell) \in \varsigma \wedge a \notin \mathrm{dom}(\varsigma')\}$.
        Intuitively, this represents merging the changes from $\varsigma'$ back into $\varsigma$. Note that this operation is NOT commutative!
    \item $\varsigma \oplus_a \varsigma'$ is defined to be $\{(a', \ell) \; | \; (a', \ell) \in \varsigma' \wedge a' \neq a\} \cup \{(a', \ell) \; | \; (a', \ell) \in \varsigma \wedge (a' = a \vee a' \notin \mathrm{dom}(\varsigma'))\}$.
        Intuitively, this represents merging the changes from $\varsigma'$ back into $\varsigma$, but excluding any updates to $a$. Note that this operation is NOT commutative!
    \item $\rho_r \ominus_A \rho_r'$ is defined to be $\{A' \; | \; A' \in \rho_r \wedge A' \neq A\} \cup \{A \; | \; A \in \rho_r\}$. In other words, this is $\rho_r$ with all instances of $A$ removed and replaced with all instances of $A$ in $\rho_r'$.
    \item $\rho_w \ominus_A \rho_w'$ is defined to be $\{(A', \ell) \; | \; (A', \ell) \in \rho_w \wedge A' \neq A\} \cup \{(A, \ell) \; | \; (A, \ell) \in \rho_w\}$. In other words, this is $\rho_w$ with all pairs containing $A$ removed and replaced with all pairs containing $A$ in $\rho_w'$.
    \item $\omega \triangleleft \sigma$ is $\omega$ with $\sigma$ pushed onto it.
    \item $\omega \triangleleft (\omega', \omega'')$ is $\omega$ with $(\omega', \omega'')$ pushed onto it.
    \item $\omega \diamond \sigma$ is $\omega$ with its top element replaced with $\sigma$ (this operation gets `stuck' if $\omega$ happens to be empty).
    \item $\omega \diamond (\omega', \omega'')$ is $\omega$ with its top element replaced with $(\omega', \omega'')$ (this operation gets `stuck' if $\omega$ happens to be empty).
    \item $\omega \; \triangleright$ is $\omega$ with its top element popped off (this operation gets `stuck' if $\omega$ happens to be empty).
    \item $\omega \triangleright \sigma$ assigns $\sigma$ to be the top element of $\omega$ (this operation gets `stuck' if $\omega$ happens to be empty).
    \item $\omega \triangleright (\omega', \omega'')$ assigns $(\omega', \omega'')$ to be the top element of $\omega$ (this operation gets `stuck' if $\omega$ happens to be empty).
    \item $+, -$ represent adding and removing an element from a multiset or multimap, respectively.
\end{enumerate}

It is an invariant that $\varsigma_w \subseteq \varsigma_r \subseteq \mathrm{dom}(\varsigma)$; likewise, it is an invariant that $\rho_r \cup \mathrm{dom}(\rho_w) \subseteq \rho$.

$\sigma$ is initialized to be $\{\varnothing, \varnothing, \varnothing, \varnothing, \varnothing, \varnothing, \langle \rangle\}$.

\subsection{Small-Step Semantics}
\subsubsection{Boolean Rules}
$$
    \frac{}{\sigma \models \ell : \ell} \qquad
    \frac{\sigma \models \mathrm{b} : \top}{\sigma \models \neg \mathrm{b} : \bot} \qquad
    \frac{\sigma \models \mathrm{b} : \bot}{\sigma \models \neg \mathrm{b} : \top} \qquad
    \frac{\sigma \models \mathrm{b} : \top \quad \sigma \models \mathrm{b}' : \top}{\sigma \models \mathrm{b} \wedge \mathrm{b}' : \top} \qquad
    \frac{\sigma \models \mathrm{b} : \bot}{\sigma \models \mathrm{b} \wedge \mathrm{b}' : \bot} \qquad
    \frac{\sigma \models \mathrm{b}' : \bot}{\sigma \models \mathrm{b} \wedge \mathrm{b}' : \bot} $$$$
    \frac{\sigma \models \mathrm{b} : \bot \quad \sigma \models \mathrm{b}' : \bot}{\sigma \models \mathrm{b} \vee \mathrm{b}' : \bot} \qquad
    \frac{\sigma \models \mathrm{b} : \top}{\sigma \models \mathrm{b} \vee \mathrm{b}' : \top} \qquad
    \frac{\sigma \models \mathrm{b}' : \top}{\sigma \models \mathrm{b} \vee \mathrm{b}' : \top} \qquad
    \frac{a \in \sigma[\varsigma_r] \quad (a, \ell) \in \sigma}{\sigma \models a : \ell} $$$$
    \frac{A \in \sigma[\rho_r]}{\sigma \models \overline{A?} : \top} \qquad
    \frac{A \notin \sigma[\rho_r]}{\sigma \models \overline{A} : \bot} \qquad
    \frac{(A, \ell) \in \sigma[\rho_w]}{\sigma \models \overline{A!} : \top} \qquad
    \frac{(A, \ell) \notin \sigma[\rho_w]}{\sigma \models \overline{A!} : \bot} \qquad
    \frac{(A, \ell) \in \sigma[\rho_w]}{\sigma \models \widehat{A} : \ell}
$$

\subsubsection{LTS Rules}
Here we use $\delta$ as a metasyntactic variable for the labels on transitions.
$$
    % skip, assign, sequential and parallel composition rules
    \frac{}{\langle \mathtt{skip}; P, \sigma \rangle \xrightarrow{\tau} \langle P, \sigma \rangle} \qquad
    \frac{a \in \sigma[\varsigma_w] \quad \sigma \models \mathrm{b} : \ell}{\langle a := \mathrm{b}, \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip}, \sigma \oslash_\varsigma (\sigma[\varsigma] \oplus \{(a, \ell)\}) \rangle} $$$$
    \frac{\langle P, \sigma \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle}{\langle P ; Q, \sigma \rangle \xrightarrow{\delta} \langle P' ; Q, \sigma' \rangle} \qquad
%   \frac{}{\langle P || Q, \sigma \rangle \xrightarrow{\tau} \langle P || Q, \sigma \oslash_\omega \sigma[\omega] \triangleleft (\sigma[\omega], \sigma[\omega]) \rangle} \qquad
    \frac{\langle P, \sigma \oslash_{\varsigma_w} \varnothing \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\delta} \langle P' || Q, \sigma \rangle} \qquad
    \frac{\langle Q, \sigma \oslash_{\varsigma_w} \varnothing \rangle \xrightarrow{\delta} \langle Q', \sigma' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\delta} \langle P || Q', \sigma \rangle} $$$$
    % selection rules
    \frac{\sigma \models \textrm{b}_i \quad \sigma \models \lnot \mathrm{b}_1 \wedge \; \ldots \; \wedge \; \lnot \mathrm{b}_{i-1} \; \wedge \lnot \mathrm{b}_{i+1} \wedge \; \ldots \; \wedge \; \lnot\mathrm{b}_n } {\langle [ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i , \sigma\rangle  } \qquad
    \frac{\sigma \models \textrm{b}_i} {\langle [ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i , \sigma\rangle  } $$$$
    \frac{\sigma \models \lnot b_1 \wedge \ldots \wedge \lnot b_n}{\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip} , \sigma\rangle } \qquad
    \frac{\sigma \models \lnot b_1 \wedge \ldots \wedge \lnot b_n}{\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip} , \sigma \rangle } $$$$
%   \frac{\langle S, \sigma \rangle \xrightarrow{\tau} \langle P, \sigma \rangle}{\langle *S, \sigma \rangle \xrightarrow{\tau} \langle P;*S, \sigma \rangle} $$$$
    \frac{\sigma \models \textrm{b}_i \quad \sigma \models \lnot \mathrm{b}_1 \wedge \; \ldots \; \wedge \; \lnot \mathrm{b}_{i-1} \wedge \lnot \mathrm{b}_{i+1} \wedge \; \ldots \; \wedge \; \lnot\mathrm{b}_n } {\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i; \; *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  } $$$$
    \frac{\sigma \models \textrm{b}_i} {\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i;\;*[ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  } $$$$
    % new, NEW rules
    \frac{}{\langle \mathtt{new} \; a \; P, \sigma \rangle \xrightarrow{\tau} \langle \underline{\mathtt{new} \; a \; P}, \sigma \oslash_\omega (\sigma[\omega] \triangleleft \sigma \odot a) \rangle} \qquad
    \frac{}{\langle \underline{\mathtt{new} \; a \; \mathtt{skip}}, \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip}, \sigma \oslash_\omega (\sigma[\omega] \; \triangleright) \rangle} $$$$
    \frac{\sigma[\omega] \triangleright \sigma' \quad \langle P, \sigma' \rangle \xrightarrow{\delta} \langle P', \sigma'' \rangle}{\langle \underline{\mathtt{new} \; a \; P}, \sigma \rangle \xrightarrow{\delta} \langle \underline{\mathtt{new} \; a \; P'}, \sigma'' \oslash_\varsigma (\sigma[\varsigma] \oplus_a \sigma''[\varsigma]) \oslash_{\varsigma_r} \sigma[\varsigma_r] \oslash_{\varsigma_w} \sigma[\varsigma_w] \oslash_\omega (\sigma[\omega] \diamond \sigma'') \rangle} $$$$
    \frac{}{\langle \mathtt{NEW} \; A \; P, \sigma \rangle \xrightarrow{\tau} \langle \underline{\mathtt{NEW} \; A \; P}, \sigma \oslash_\omega (\sigma[\omega] \triangleleft \sigma \odot A) \rangle} \qquad
    \frac{}{\langle \underline{\mathtt{NEW} \; A \; \mathtt{skip}}, \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip}, \sigma \oslash_\omega (\sigma[\omega] \; \triangleright) \rangle} $$$$
    \frac{\sigma[\omega] \triangleright \sigma' \quad \langle P, \sigma' \rangle \xrightarrow{\delta} \langle P', \sigma'' \rangle \quad A?a : \ell \notin \delta \quad A!\ell \notin \delta}{\langle \underline{\mathtt{NEW} \; A \; P}, \sigma \rangle \xrightarrow{\delta} \langle \underline{\mathtt{NEW} \; A \; P'}, \sigma'' \oslash_\rho \sigma[\rho] \oslash_{\rho_r} (\sigma''[\rho_r] \ominus_A \sigma[\rho_r]) \oslash_{\rho_w} (\sigma''[\rho_w] \ominus_A \sigma[\rho_w]) \oslash_\omega (\sigma[\omega] \diamond \sigma'') \rangle} $$$$
    % communication rules
    \frac{A \in \sigma[\rho] \quad a \in \sigma[\varsigma_w]}{\langle A?a, \sigma \rangle \xrightarrow{\tau} \langle \underline{A?a}, \sigma \oslash_{\rho_r} (\sigma[\rho_r] + A) \rangle} \qquad
    \frac{A \in \sigma[\rho] \quad \sigma \models \mathrm{b} : \ell}{\langle A!\mathrm{b}, \sigma \rangle \xrightarrow{\tau} \langle \underline{A!\ell}, \sigma \oslash_{\rho_w} (\sigma[\rho_w] + (A, \ell)) \rangle} $$$$
    \frac{}{\langle \underline{A?a}, \sigma \rangle \xrightarrow{\{A?a : \ell\}} \langle \mathtt{skip}, \sigma \oslash_\varsigma (\sigma[\varsigma] \oplus \{(a, \ell)\}) \oslash_{\rho_r} (\sigma[\rho_r] - A) \rangle} $$$$
    \frac{}{\langle \underline{A!\ell}, \sigma \rangle \xrightarrow{\{A!\ell\}} \langle \mathtt{skip}, \sigma \oslash_{\rho_w} (\sigma[\rho_w] - (A, \ell)) \rangle} $$$$
    \frac{A \in \sigma[\rho] \quad a \in \sigma[\varsigma_w] \quad \langle C, \sigma \rangle \xrightarrow{\tau} \langle \underline{C}, \sigma' \rangle}{\langle A?a \bullet C, \sigma \rangle \xrightarrow{\tau} \langle \underline{A?a \bullet C}, \sigma' \oslash_{\rho_r} (\sigma'[\rho_r] + A) \rangle} \qquad
    \frac{A \in \sigma[\rho] \quad \sigma \models \mathrm{b} : \ell \quad \langle C, \sigma \rangle \xrightarrow{\tau} \langle \underline{C}, \sigma' \rangle}{\langle A!\mathrm{b} \bullet C, \sigma \rangle \xrightarrow{\tau} \langle \underline{A!\ell \bullet C}, \sigma' \oslash_{\rho_w} (\sigma'[\rho_w] + (A, \ell)) \rangle} $$$$
    \frac{\langle \underline{C}, \sigma \rangle \xrightarrow{\delta} \langle \mathtt{skip}, \sigma' \rangle}{\langle \underline{A?a \bullet C}, \sigma \rangle \xrightarrow{\delta + \{A?a : \ell\}} \langle \mathtt{skip}, \sigma' \oslash_\varsigma (\sigma'[\varsigma] \oplus \{(a, \ell)\}) \oslash_{\rho_r} (\sigma'[\rho_r] - A) \rangle} $$$$
    \frac{\langle \underline{C}, \sigma \rangle \xrightarrow{\delta} \langle \mathtt{skip}, \sigma' \rangle}{\langle \underline{A!\ell \bullet C}, \sigma \rangle \xrightarrow{\delta + \{A!\ell\}} \langle \mathtt{skip}, \sigma' \oslash_{\rho_w} (\sigma'[\rho_w] - (A, \ell)) \rangle} $$$$
    \frac{\langle P, \sigma \rangle \xrightarrow{\{A!\ell\}} \langle P', \sigma' \rangle \quad \langle Q, \sigma' \rangle \xrightarrow{\{A?a : \ell\}} \langle Q', \sigma'' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\tau} \langle P' || Q', \sigma'' \rangle} \qquad
    \frac{\langle P, \sigma \rangle \xrightarrow{\{A?a : \ell\}} \langle P', \sigma' \rangle \quad \langle Q, \sigma' \rangle \xrightarrow{\{A!\ell\}} \langle Q', \sigma'' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\tau} \langle P' || Q', \sigma'' \rangle} $$$$
    \frac{\begin{matrix} \langle P, \sigma \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle \quad \langle P'', \sigma' \rangle \xrightarrow{\delta'} \langle P''', \sigma'' \rangle \quad \langle P || P'', \sigma \rangle \xrightarrow{\tau} \langle P' || P''', \sigma'' \rangle \\ \langle Q, \sigma''' \rangle \xrightarrow{\delta + A?a : \ell} \langle Q', \sigma'''' \rangle \quad \langle Q'', \sigma'''' \rangle \xrightarrow{\delta' + A!\ell} \langle Q''', \sigma''''' \rangle \end{matrix}}{\langle Q || Q'', \sigma''' \rangle \xrightarrow{\tau} \langle Q' || Q''', \sigma''''' \rangle} $$$$
    \frac{\begin{matrix} \langle P, \sigma \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle \quad \langle P'', \sigma' \rangle \xrightarrow{\delta'} \langle P''', \sigma'' \rangle \quad \langle P || P'', \sigma \rangle \xrightarrow{\tau} \langle P' || P''', \sigma'' \rangle \\ \langle Q, \sigma''' \rangle \xrightarrow{\delta + A!\ell} \langle Q', \sigma'''' \rangle \quad \langle Q'', \sigma'''' \rangle \xrightarrow{\delta' + A?a : \ell} \langle Q''', \sigma''''' \rangle \end{matrix}}{\langle Q || Q'', \sigma''' \rangle \xrightarrow{\tau} \langle Q' || Q''', \sigma''''' \rangle}
$$

The labels need to be multisets, unless channels are end-to-end, in which case they just need to be sets.

%All of the following rules work up to structural congruence ($\equiv$), which is defined by $\alpha$ conversion and the following rules:
%
%\[
%P || \mathtt{skip} \equiv P \;\;\;\;\;  P || Q \equiv Q || P %  \;\;\;\;\;  \mathtt{skip}; P \equiv P \\
%\]
%\[
%P || (Q || R) \equiv (P || Q) || R 
%\]
%\[
%A \bullet B \equiv B \bullet A \;\;\;\;\; ( A \bullet B ) \bullet C \equiv A \bullet ( B \bullet C )
%\]
%
%Additionally, the following rules are augmented by an environment, $\sigma$, which is a mapping from variables to boolean values, $\sigma : \textrm{Var} \rightarrow \mathcal{B}$ 
%
%Boolean simplification $\overset{b}{\rightarrow}$ works as typical on AND and OR, though it is also extended with channel probes ($\bar{A}$), which are true  ($\top$) when a channel wishes to communicate on channel A, and false ($\perp$) otherwise and value probes ($\widehat{A}$), which are defined below \textbf{XXX: We should probably define an actual boolean simplification set which includes both probes and value probes.  I couldn't think of a good way to express them easily, as both of these need a context.}.
%
%\begin{align*}
%% Remove a skip statement
%\frac{}{\langle \mathtt{skip}; P, \sigma \rangle \rightarrow \langle P, \sigma \rangle } & \\ \\
%% Simplify boolean under assignment
%\frac{\langle \textrm{b}, \sigma \rangle \overset{b}{\rightarrow} \langle \textrm{b}^\prime, \sigma \rangle}{\langle a := b, \sigma\rangle \overset{b}{\rightarrow}  \langle a := b', \sigma \rangle} &\;\; 
%% Assignment
%\frac{}{\langle a := \ell, \sigma\rangle \rightarrow \langle \mathtt{skip}, \sigma[\ell/a] \rangle } \\ \\
%% Sequential Composition
%\frac{\langle P_1, \sigma\rangle \rightarrow \langle P_1^\prime, \sigma^\prime\rangle }{\langle P_1; P_2, \sigma\rangle \rightarrow \langle P_1^\prime; P_2, \sigma^\prime\rangle} &
%% Parallel Composition
%\;\; \frac{\langle P_1, \sigma\rangle \rightarrow \langle P_1^\prime, \sigma^\prime\rangle}{\langle P_1 || P_2, \sigma\rangle \rightarrow \langle P_1^\prime || P_2, \sigma^\prime\rangle} \\ \\
%% Deterministic Selection
%\frac{\sigma \models \textrm{b}_i \;\;\; \sigma \models \lnot \mathrm{b}_1 \wedge \; ... \; \wedge \; \lnot \mathrm{b}_{i-1} \; \wedge \lnot \mathrm{b}_{i+1} \wedge \; ... \; \wedge \; \lnot\mathrm{b}_n } {\langle [ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i , \sigma\rangle  } &\;\;
%% Non-deterministic Selection
%\frac{\sigma \models \textrm{b}_i} {\langle [ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i , \sigma\rangle  } \\ \\
%% Repeated Deterministic Selection no option good
%\frac{\sigma \models \lnot b_1 \wedge ... \wedge \lnot b_n}{\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle \mathtt{skip} , \sigma\rangle } &\;\; 
%% Repeated Non-deterministic Selection no options good
%\frac{\sigma \models \lnot b_1 \wedge ... \wedge \lnot b_n}{\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle \mathtt{skip} , \sigma \rangle } 
%\end{align*}
%
%\begin{align*}
%% Repeated Deterministic Selection
%\frac{\sigma \models \textrm{b}_i \;\;\; \sigma \models \lnot \mathrm{b}_1 \wedge \; ... \; \wedge \; \lnot \mathrm{b}_{i-1} \wedge \lnot \mathrm{b}_{i+1} \wedge \; ... \; \wedge \; \lnot\mathrm{b}_n } {\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i; \; *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  } \\
%% Repeated Nondeterministic Selection
%\\ \frac{\sigma \models \textrm{b}_i} {\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i;\;*[ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  }
%\end{align*}
%
%\begin{align*}
%% Simplify Booleans under send
%\frac{\langle \textrm{b}, \sigma \rangle \overset{b}{\rightarrow} \langle \textrm{b}^\prime, \sigma \rangle}{\langle A!b, \sigma\rangle \overset{b}{\rightarrow}  \langle A!b', \sigma \rangle} &\;\; 
%% Value probe
%\frac{}{\langle A\# \; || \; A!\ell , \sigma\rangle \overset{b}{\rightarrow} \langle \ell \;||\;A!\ell, \sigma \rangle} \\ \\
%% Channel probe?
%% Communication
%\frac{} {\langle A!\ell || A?a, \sigma \rangle \rightarrow \langle \mathtt{skip} ,\sigma[\ell/a] \rangle} &\;\; 
%% Parallel/Series composition
%\frac{\langle P_1 || ... || P_n, \sigma \rangle \rightarrow \langle P_1^\prime || ... || P_n^\prime, \sigma^\prime \rangle } {\langle P_1;\;Q_1 || ... || P_n;\;Q_n, \sigma \rangle \rightarrow \langle P_1^\prime;\;Q_1 || ... || P_n^\prime;\; Q_n, \sigma^\prime \rangle } \\ \\
%% Bullet Send
%\frac{ \langle C \; || \; P, \sigma \rangle \rightarrow \langle \mathtt{skip} \; || \; P^\prime, \sigma^\prime \rangle }{ \langle C \bullet A!\ell \; || \; P \; || \; A?a , \sigma \rangle
%\rightarrow \langle \mathtt{skip} \; || \; P^\prime,  \sigma'[\ell/a]  \rangle } & \;\;
%% Bullet receive
%\frac{ \langle C \; || \; P, \sigma \rangle \rightarrow \langle \mathtt{skip} \; || \; P^\prime, \sigma^\prime \rangle }{ \langle C \bullet A?a \; || \; P \; || \; A!\ell , \sigma \rangle
%\rightarrow \langle \mathtt{skip} \; || \; P^\prime,  \sigma'[\ell/a]  \rangle }
%\end{align*}
%
%\begin{align*}
%% Bullet send and recieve
%\frac{ \langle C_1 \; || \; C_2 \; || \; P, \sigma \rangle \rightarrow \langle \mathtt{skip} \; || \; P^\prime , \sigma^\prime \rangle }{ \langle C_1 \bullet A!\ell \; || \; C_2 \bullet A?a \; || \; P , \sigma \rangle \rightarrow \langle  \mathtt{skip} \; || \; P^\prime, \sigma^\prime[\ell/a] \rangle } & 
%\end{align*}

\section{HSE}

One level lower is the handshaking expansions, which remove operations on channels, and operations on non-booleans.

\subsection{Grammar}

\begin{align*}
\ell & ::= \top \; | \perp \\
\mathrm{b} & ::= a \; | \ell \; | \; \mathrm{b}_1 \wedge \mathrm{b}_2 \; | \; \mathrm{b}_1 \vee \mathrm{b}_2 \; | \; \lnot \mathrm{b} \; | \; ( \mathrm{b} ) \\
\mathrm{P} & ::= a\uparrow \; | \; a\downarrow \; | \; S \; | \; *S \; | \; P_1; P_2 \; | \: P_1 || P_2 \; | \; \mathtt{skip} \; | ( P )  \\
\mathrm{S} & ::= [ b_1 \rightarrow P_1  \talloblong \; ... \; \talloblong b_n \rightarrow P_n ] \; | \; [ b_1 \rightarrow P_1 | \; ... \; | b_n \rightarrow P_n ]
\end{align*}

Above, we are using $a ... z$ to range over variables, and $A ... Z$ to range over channels.

Additionally, there is some well-accepted syntactic sugar:

$*[S]$ is syntactic sugar for $*[ \top \; \rightarrow \; S]$, which is used for infinite loops. 

$[\textrm{b}]$ is used to mean $[\textrm{b} \; \rightarrow \mathtt{skip}]$, which means that we wait for a boolean expression to be true before continuing.

\subsection{Small-Step Semantics}

\begin{align*}
% Remove a skip statement
\frac{}{\langle \mathtt{skip}; P, \sigma \rangle \rightarrow \langle P, \sigma \rangle } & \\ \\
% Assignment
\frac{}{\langle a \uparrow , \sigma\rangle \rightarrow \langle \mathtt{skip}, \sigma[\top/a]\rangle } &\;\; 
\frac{}{\langle a \downarrow , \sigma\rangle \rightarrow \langle \mathtt{skip}, \sigma[\perp/a]\rangle }
\end{align*}

\begin{align*}
% Sequential Composition
\frac{\langle P_1, \sigma\rangle \rightarrow \langle P_1^\prime, \sigma^\prime\rangle }{\langle P_1; P_2, \sigma\rangle \rightarrow \langle P_1^\prime; P_2, \sigma^\prime\rangle} &
%Parallel Composition
\;\; \frac{\langle P_1, \sigma\rangle \rightarrow \langle P_1^\prime, \sigma^\prime\rangle}{\langle P_1 || P_2, \sigma\rangle \rightarrow \langle P_1^\prime || P_2, \sigma^\prime\rangle} \\ \\
% Deterministic Selection
\frac{\sigma \models \textrm{b}_i \;\;\; \sigma \models \lnot \mathrm{b}_1 \wedge \; ... \; \wedge \lnot \mathrm{b}_{i-1} \wedge \lnot \mathrm{b}_{i+1} \wedge \; ... \; \wedge \; \lnot\mathrm{b}_n } {\langle [ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i , \sigma\rangle  } &\;\;
%Non-deterministic Selection
 \frac{\sigma \models \textrm{b}_i} {\langle [ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i , \sigma\rangle  } \\ \\
% Repeated Deterministic Selection no option good
\frac{\sigma \models \lnot b_1 \wedge ... \wedge \lnot b_n}{\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle \mathtt{skip} , \sigma\rangle } &\;\; 
% Repeateed Non-deterministic Selection no options good
\frac{\sigma \models \lnot b_1 \wedge ... \wedge \lnot b_n}{\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle \mathtt{skip} , \sigma \rangle } 
\end{align*}

\begin{align*}
% Repeated Deterministic Selection
\frac{\sigma \models \textrm{b}_i \;\;\; \sigma \models \lnot \mathrm{b}_1 \wedge \; ... \; \wedge \lnot \mathrm{b}_{i-1} \wedge \lnot \mathrm{b}_{i+1} \wedge \; ... \; \wedge \; \lnot\mathrm{b}_n } {\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i; \; *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  } \\
% Repeated Nondeterministic Selection
\\ \frac{\sigma \models \textrm{b}_i} {\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \rightarrow \langle P_i;\;*[ \mathrm{b}_1 \rightarrow P_1  | \; ... \; | \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  }
\end{align*}
\section{PRS}

The production rule set is the lowest non-circuit level.  It represents the logical operations that happen in circuits. 

\subsection{Grammar}

The production rules are represented as a set, $\Xi$, consisting of boolean guards, $G_{x\uparrow}$ and $G_{x\downarrow}$ for each variable $x$ in the program.  These rules take the form:

\begin{align*}
\mathrm{b} & ::= a \; | \; \mathit{l} \; | \; \mathrm{b} _1 \wedge \mathrm{b}_2 \; | \; \mathrm{b}_1 \vee \mathrm{b}_2 \; | \; \lnot \mathrm{b} \; | \; ( \mathrm{b} ) \\
G_{x\uparrow} &::= \mathrm{b} \mapsto x\uparrow  \\
G_{x\downarrow} &::= \mathrm{b} \mapsto x\downarrow 
\end{align*}

N.B. The choice for $\Xi$ is arbitrary and not based on any previous literature.  If there is actually a symbol that's used for the PR Set somewhere else, we should use that.

\subsection{Semantics}

\begin{align*}
% Rule firing that makes a variable true
\frac{G_{x\uparrow} \in \Xi  \;\;\;\;  \sigma \models G_{x\uparrow} }{\langle \Xi, \sigma \rangle \rightarrow  \langle \Xi , \sigma[\top/x]\rangle} &\;\; 
% Rule firing that makes a variable false
\frac{G_{x\downarrow} \in \Xi  \;\;\;\;  \sigma \models G_{x\downarrow} }{\langle \Xi, \sigma \rangle \rightarrow \langle \Xi , \sigma[\perp/x]\rangle}
\end{align*}

\subsection{Properties}

A few additional properties must be obeyed.  First, the rule of non-interference, which states that it can never be the case that both the pull-up ($G_{x\uparrow}$) and pull-down $G_{x\downarrow}$ are active at the same time.  This needs to be true for implementability -- both guards being true corresponds to a transistor short-circuit.

Additionally, there is the rule of stability, which states that $G_{x\uparrow}$ can only change from true to false in states where $x$ is true, and $G_{x\downarrow}$ can only change from false to true in states where $x$ is false.

\section{Na\"{i}ve Synthesis} 

The synthesis process from CHP$\rightarrow$HSE$\rightarrow$PRS is an interesting problem.  A na\"{i}ve solution to it is presented below.

The five steps that we will follow in synthesis are:

\begin{enumerate}
\item CHP Generation
\item Handshaking Expansion
\item Ambiguous States Identification
\item State Variable Insertion
\item Production Rule Synthesis
\end{enumerate}

\subsection{CHP Generation}

For this example, we are going to be using a simple one-place dataless buffer:

\begin{align*}
*[L?;R!]
\end{align*}

This reads in a dataless value from L, and sends one out on R.  It is not particularly useful, but it will serve for this example.  A more complicated CHP program might be broken-up at this stage into several parallel programs, using the techniques of projection or process decomposition. 

\subsection{Handshaking Expansion}

We will be using a four-phase handshake on both of the channels.  Using this, the above expands to

%\begin{hse}
%*[lo+; [li]; lo-; [~li]; [ri]; ro+; [~ri]; ro-]
%\end{hse}

\begin{align*} 
*\textbf{[}l_o \! \uparrow; \; \textbf{[}l_i\textbf{]}; \; l_o\!\downarrow; \; \textbf{[}~l_i\textbf{]}; \; \textbf{[}r_i\textbf{]}; \; r_o \! \uparrow; \; \textbf{[}~r_i\textbf{]}; \; r_o \! \downarrow\textbf{]}
\end{align*}


\subsection{Ambiguous State Identification}

To identify ambiguous states, we will first annotate the handshaking expansion with the states that it can be in at any point.  Each point in the program will be annotated with a vector representing $(l_o, l_i, r_o, r_i)$ We will be using 'X' to represent the times where we don't know if a value is true or false.

%\begin{hse}
%*[^{\color{blue}(000X)} lo+^{\color{red}(1X0X)}; [li]^{\color{red}(110X)}; lo-^{(010X)}; [~li]^{\color{blue}(000X)}; [ri]^{\color{blue}(0001)}; ro+^{\color{green}(001X)}; [~ri]^{\color{green}(0010)}; ro-^{\color{blue}(000X)}]
%\end{hse}

\begin{align*} 
*\textbf{[} ^{\color{blue}(000X)} \;  l_o \! \uparrow^{\color{red}(1X0X)}; \; \textbf{[}l_i\textbf{]}^{\color{red}(110X)}; \; l_o\!\downarrow^{(010X)}; \; \textbf{[}~l_i\textbf{]}^{\color{blue}(000X)}; \; \textbf{[}r_i\textbf{]}^{\color{blue}(0001)}; \; r_o \! \uparrow^{\color{green}(001X)}; \; \textbf{[}~r_i\textbf{]}^{\color{green}(0010)}; \; r_o \! \downarrow^{\color{blue}(000X)}\textbf{]}
\end{align*}

Each set of ambiguous states has been colored above.  The red and green sets do not matter, as they are immediately before and after a wait, where we expect to see an ambiguity due to the X.  However, the blue states are interesting since they're distributed throughout the program, and we would like different things to happen at each of them. 


\subsection{State Variable Insertion}

To eliminate ambiguous states in the above handshaking expansion, we can insert a state variable, $s$.  To demonstrate the removal of ambiguity, the vector will be updated, as $(l_o, l_i, r_o, r_i, s)$.

%\begin{hse}
%*[^{\color{blue}(000X0)} lo+^{\color{red}(1X0X0)}; [li]^{\color{red}(110X0)}; s+^{(110X1)}; lo-^{(010X1)}; [~li]^{(000X1)}; 
%        [ri]^{(00011)}; ro+^{\color{green}(001X1)}; [~ri]^{\color{green}(00101)}; s-^{(00100)}; ro-^{\color{blue}(000X0)}]
%\end{hse}

\begin{align*} 
*\textbf{[} ^{\color{blue}(000X0)} \;  l_o \! \uparrow^{\color{red}(1X0X0)}; \; \textbf{[}l_i\textbf{]}^{\color{red}(110X0)}; \; s\!\uparrow^{(110X1)}; \; l_o\!\downarrow^{(010X1)}; \; \textbf{[}~l_i\textbf{]}^{(000X1)}; \\
\textbf{[}r_i\textbf{]}^{(00011)}; \; r_o \! \uparrow^{\color{green}(001X1)}; \; \textbf{[}~r_i\textbf{]}^{\color{green}(00101)}; \; s\!\downarrow^{(00100)}; \; r_o \! \downarrow^{\color{blue}(000X0)}\textbf{]}
\end{align*}

There are still ambiguous states after we have added in the state variables, however, all of them are either essentially the same state (such as in the case of the blue ambiguity) or do not matter (as in the case of the red and green ambiguity).

\subsection{Production Rule Synthesis}

There are two systematic methods for production rule generation, the first is to guard each and every action with the entirety of the (non-ambiguous) state at the moment it would like to fire, and then reducing the number of guards, and the second is to build up the guards by successively adding to them.  Below we present the first method:

\begin{enumerate}

\item Initial Set

%\begin{prs2}
%~lo & ~li & ~ro & ~s -> lo+
%lo & li & ~ro & s-> lo-

%~lo & ~li & ~ro & ri & s -> ro+
%~lo & ~li & ro & ~ri & s -> ro-

%lo & li & ~ro & ~s -> s+
%~lo & ~li & ro & ~ri & s -> s-
%\end{prs2}

\begin{align*}
\lnot l_o \wedge \lnot l_i \wedge \lnot r_o \wedge \lnot s & \mapsto l_o \uparrow & \lnot l_o \wedge \lnot l_i \wedge \lnot r_o \wedge r_i \wedge s  & \mapsto r_o \uparrow \\
l_o \wedge l_i \wedge \lnot r_o \wedge s & \mapsto l_o \downarrow  & \lnot l_o \wedge \lnot l_i \wedge r_o \wedge \lnot r_i \wedge s & \mapsto r_o\downarrow \\ \\
l_o \wedge l_i \wedge \lnot r_o \wedge \lnot s & \mapsto s\uparrow & & \\
\lnot l_o \wedge \lnot l_i \wedge r_o \wedge \lnot r_i \wedge s & \mapsto s\downarrow & & 
\end{align*}

\item First Reduction

Every rule in the first set was "self-invalidating", meaning that the output of the rule appeared as part of the guard.  As this is not possible to implement, this is removed as the first transformation.  Doing this changes the states the rules can fire in subtlety -- each of them now can also fire in the states where their result has occurred.  This is OK.

%\begin{prs2}
%~li & ~ro & ~s -> lo+
%li & ~ro & s-> lo-

%~lo & ~li & ri & s -> ro+
%~lo & ~li & ~ri & s -> ro-

%lo & li & ~ro -> s+
%~lo & ~li & ro & ~ri  -> s-
%\end{prs2}

\begin{align*}
\lnot l_i \wedge \lnot r_o \wedge \lnot s & \mapsto l_o \uparrow & \lnot l_o \wedge \lnot l_i \wedge r_i \wedge s  & \mapsto r_o \uparrow \\
l_i \wedge \lnot r_o \wedge s & \mapsto l_o \downarrow  & \lnot l_o \wedge \lnot l_i \wedge \lnot r_i \wedge s & \mapsto r_o\downarrow \\ \\
l_o \wedge l_i \wedge \lnot r_o& \mapsto s\uparrow & & \\
\lnot l_o \wedge \lnot l_i \wedge r_o \wedge \not r_i & \mapsto s\downarrow & & 
\end{align*}

\item A Few More

After a few more reductions, we get the set below.  None of these rules can fire except in the states where they should, or in the states where they already hold.

%\begin{prs2}
%~ro & ~s -> lo+
%li & s-> lo-

%~li & ri & s -> ro+
%~lo & s -> ro-

%li -> s+
%~ri  -> s-
%\end{prs2}

\begin{align*}
\lnot r_o \wedge \lnot s & \mapsto l_o \uparrow & \lnot l_i \wedge r_i \wedge s  & \mapsto r_o \uparrow \\
l_i \wedge \wedge s & \mapsto l_o \downarrow  & \lnot l_o \wedge s & \mapsto r_o\downarrow \\ \\
l_i & \mapsto s\uparrow & & \\
\lnot r_i & \mapsto s\downarrow & & 
\end{align*}


\item Further Transformations

As this production rule set exists, it is not CMOS-implementable.  In order to be CMOS-implementable, each production rule of the form $G_{x\uparrow}$ must only use the inverted sense of variables in its guards, and each of the form $G_{x\downarrow}$ must use the non-inverted sense.  Making this transformation may involve the insertion of additional variables, and is known as bubble reshuffling. 

\end{enumerate}

\subsection{Discussion}

The method above works for simple processes, however, it expands quickly when applied to large processes.  It does not address the technique of handshake reshuffling, where the waits in the expanded handshakes are re-ordered to remove ambiguous states.  This process is one where great care needs to be taken, as it can eliminate possible actions, and constrains other processes to needing compatible reshuffling.

\section{Handshaking Reshuffling}

The na\"{i}ve synthesis method presented above will create handshaking expansions without ambiguous states, however, in many cases it will result in very inefficient implementations with a very large number of state variables. 

To take the single-place buffer from above, we originally had:

\begin{align*} 
*\textbf{[}l_o \! \uparrow; \; \textbf{[}l_i\textbf{]}; \; l_o\!\downarrow; \; \textbf{[}~l_i\textbf{]}; \; \textbf{[}r_i\textbf{]}; \; r_o \! \uparrow; \; \textbf{[}~r_i\textbf{]}; \; r_o \! \downarrow\textbf{]}
\end{align*}

Which has ambiguous states in it. However, it is possible to reorder the sequence of events to not have any significant ambiguities while at the same time still preserving many of the possible sets of behaviors.

One such reshuffling is known as the "Weak Charge Half Buffered" or WCHB reshuffling, and it looks like:

% *[[Re & Ld]; Rd+; Le-; [~Re & ~Ld]; Rd-, Le+]

\begin{align*}
*\textbf{[}l_o \! \uparrow; \; \textbf{[}  r_i \wedge l_i  \textbf{]} \;; r_o\!\uparrow;  \;l_o \! \downarrow; \; \textbf{[}  \lnot r_i \wedge \lnot l_i  \textbf{]};  \; r_o\!\downarrow  \textbf{]} 
\end{align*} 


%\section{Handshaking Rehsuffling}

%The na\"{i}ve synthesis method above will work, but it will create very inefficient implementations in many cases.  One such case is presented below.

% Split example

%A "split" is a process that takes in a control signal and a data value, and then based on that control signal, it sends the data out to one of two places.

%\begin{hse}
%*[C?c, B?x;
%         [ c -> E!x
%         []~c -> F!x
%       ]]
%\end{hse}

%The full na\"{i}ve handshake expansion is below.  In this, channel communication has been simply replaced with the four-phase representation of that channel communication.  For space reasons, this has not been annotated with the state, however, it is easy to see that there will be many ambiguous states.

%\begin{hse}
%*[(([C.t -> c+ [] C.f -> c-]; C.e-; [~C.t & ~C.f]; C.e+ ), 
 %  ([B.t -> x+ [] B.f -> x-]; B.e-; [~B.t & ~B.f]; B.e+ ));
%         [  c -> [E.e]; [ x -> E!\top [] ~x -> E!\perp]; [~E.e]; (E.t-, E.f-)
%         [] ~c -> [F.e]; [ x -> F!\top [] ~x -> F!\perp]; [~F.e]; (F.t-, F.f-)
%       ]]
%\end{hse}

%If we re-order the handshaking expansion, we can create a system that requires absolutely zero additional state variables to operate, and we have removed the need for internal storage variables.  However, after re-ordering, there are actions that are not possible that were originally possible.  

%The reshuffling below is what is known as a "Pre-Charge Half-Buffered" reshuffling. Pre-charge, as the arrangement of transitions in the resulting production rule set allow for pre-charge of internal nodes. And half-buffered because it no longer will act as a full buffer stage for the data: it is no longer possible to have different values waiting on the input and being set on the output.  Two of them in series, or with half-buffer buffer stages on the output allows you to regain all of the behaviors of the full-buffered version, though this typically is not necessary.

%\begin{hse}
%*[[ E.e & C.t & B.t -> E.t+
%  [] E.e & C.t & B.f -> E.f+
%  [] F.e & C.f & B.t -> F.t+
%  [] F.e & C.f & B.f -> F.f+
%  ]; C.e-, B.e-;
%  [ ~E.e | (~E.t & ~E.f) -> E.t-, E.f-],
%  [ ~F.e | (~F.t & ~F.f) -> F.t-, F.f-];
%  [~C.t & C.f & ~B.t & B.f];
%  C.e+, B.e+
%]
%\end{hse}

\section{CHP to CHP Transformations}

To reduce the implementation complexity, and to increase the amount of parallelism and pipelining that is allowed, it is often advantageous to take a single CHP program and break it down into several smaller processes.

\subsection{Process Decomposition}

Process decomposition is a method for taking arbitrary sections of code and moving them into a separate process.  It does this by replacing the code to remove with a single dataless channel action, and then using that channel action to synchronize the behavior.

For example, if the original CHP is $(....; S;...)$, the decomposed CHP might be: 

\begin{align*}
& \mathtt{NEW } \; C; \\
& ...; C!; ... \\
& || *[\bar{C} \rightarrow S; C?]
\end{align*}

This can be applied to more complicated processes, such as: (note that the following is from Prof. Manohar's class notes, and is using CHP with the extension onto numbers)

\begin{align*}
&*[ x := 0; i := 0; \\
&    *[ i < 10\; \rightarrow\; I?t; x := x + t; i := i + 1]; \\
&     O!x\\
& ]
\end{align*}

This is a process that reads in 10 items from channel I, and then sends out the summation of those on channel O.  It might be helpful to move the summation on x out into a different channel.

\begin{align*}
&*[ x := 0; i := 0; \\
& \;\;\;*[ i < 10\; \rightarrow\; I?t; (A! || B!t) i := i + 1];\\
& \;\;\;\;\;\;O!x\\
& ]\\
&|| *[ \bar{A} \; \rightarrow\; B?v; x := x+v; A?]
\end{align*}

A natural extension to this is to move all of the actions on $x$ into the parallel process, as sharing variables becomes a headache once we get into implementation.

\begin{align*}
&*[ C!; \;  i := 0;\\
& \;\;\;*[ i < 10\; \rightarrow\; I?t; (A! || B!t) i := i + 1];\\
& \;\;\;\;\;\;D!\\
& ]\\
&|| *[ \bar{A} \; \rightarrow\; B?v; x := x+v; A?\\
&\;\;\;\;\;\;[] \bar{C} \; \rightarrow\; x := 0; B?\\
& \;\;\;\;\;\;[] \bar{D}\; \rightarrow\; O!x; D? \\
&  ]
\end{align*}

As the value from channel I is basically passing through B in all situations, we can replace it.  This is only possible because the dataless channel $A$ is ensuring that the value only gets read at the correct time.

\begin{align*}
&*[ C!; \;  i := 0;\\
& \;\;\;*[ i < 10\; \rightarrow\; A!; i := i + 1];\\
& \;\;\;\;\;\;D!\\
& ]\\
&|| *[ \bar{A} \; \rightarrow\; I?v; x := x+v; A?\\
&\;\;\;\;\;\;[] \bar{C} \; \rightarrow\; x := 0; B?\\
& \;\;\;\;\;\;[] \bar{D}\; \rightarrow\; O!x; D? \\
&  ]
\end{align*}

And lastly, as the selection statement will ensure the exclusivity of execution of all of its branches, and in this system, $x$ is not shared, we can do some reordering of the actions in the second process, to allow the first process to proceed more rapidly.

\begin{align*}
&*[ C!; \; i := 0;\\
& \;\;\;*[ i < 10\; \rightarrow\; A!; i := i + 1];\\
& \;\;\;\;\;\;D!\\
& ]\\
&|| *[ \bar{A} \; \rightarrow\; A?; I?v; x := x+v\\
&\;\;\;\;\;\;[] \bar{C} \; \rightarrow\; B?; x := 0\\
& \;\;\;\;\;\;[] \bar{D}\; \rightarrow\; O!x; D? \\
&  ]
\end{align*}

And now, because of this decomposition, the additions on $x$ and $i$ can happen in parallel, the processes will be simpler to implement in hardware, and will perform better.

\section{Project Goals}

\begin{enumerate}

\item Formally define the semantics for CHP, HSE, and PRS

\item Discuss Handshaking Expansions in a good way 

\item Discuss Synthesis from HSE to PRS in a better way

\item Build a system to prove CHP $\rightarrow$ CHP transformations

\item Build a system to prove HSE $\rightarrow$ HSE transformations

\item Build a system to prove equivalences for CHP $\rightarrow$ HSE transforms post-reshufflings

\end{enumerate}
\end{document}
