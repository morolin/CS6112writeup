\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{fullpage}

\begin{document}

\title{CHP Translation and LTS Semantics}
\author{}
\maketitle

\section{CHP Translation}

\subsection{HSE+ Grammar}
\begin{align*}
    \ell & ::= \top \; | \bot \\
    \mathrm{b} & ::= a \; | \; \ell \; | \; \mathrm{b}_1 \wedge \mathrm{b}_2 \; | \; \mathrm{b}_1 \vee \mathrm{b}_2 \; | \; \lnot \mathrm{b} \\
    \mathrm{P} & ::= a := \mathrm{b} \; | \; S \; | \, *S \; | \; P_1; P_2 \; | \: P_1 || P_2 \; | \; \mathtt{skip} \; | \; \{P\} \; | \; [P]_A \\
    \mathrm{S} & ::= [ \mathrm{b}_1 \rightarrow P_1 \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] \; | \; [ \mathrm{b}_1 \rightarrow P_1 | \; ... \; | \mathrm{b}_n \rightarrow P_n ] \\
\end{align*}

We will use $\{P\}$ as a marker to indicate which terms are translations of channel actions in CHP, and $[P]_A$ as a marker to indicate the scope of the channel $A$ (i.e. minimum enclosing scope outside of which no process ever performs a send or receive on $A$).
The markers are used only in the LTS semantics section, where we need to label transitions corresponding to channel actions.

\subsection{CHP Grammar}
\begin{align*}
    \ell & ::= \top \; | \bot \\
    \mathrm{b} & ::= V \; | \; \ell \; | \; \overline{A} \; | \; \mathrm{b}_1 \wedge \mathrm{b}_2 \; | \; \mathrm{b}_1 \vee \mathrm{b}_2 \; | \; \lnot \mathrm{b} \\
    \mathrm{V} & ::= a \; | \; A_a \; | \; A_t \; | \; A_v \\
    \mathrm{P} & ::= a := \mathrm{b} \; | \; S \; | \, *S \; | \; C \; | \; P_1; P_2 \; | \: P_1 || P_2 \; | \; \mathtt{skip} \\
    \mathrm{S} & ::= [ \mathrm{b}_1 \rightarrow P_1 \talloblong \; ... \; \talloblong \mathrm{b}_n \rightarrow P_n ] \; | \; [ \mathrm{b}_1 \rightarrow P_1 | \; ... \; | \mathrm{b}_n \rightarrow P_n ] \\
    \mathrm{C} & ::= A!\mathrm{b} \; | \; A?a \; | \; C_1 \bullet C_2
\end{align*}

The only terms appearing in this grammar but not the HSE+ grammar are: $\overline{A}$, $A!\mathrm{b}$, $A?a$, $C_1 \bullet C_2$.
Therefore, it suffices to give translations for just these extra terms; everything else translates to its equivalent in HSE+.
However, in order to give LTS semantics for channel operations, we need to introduce a system of labels for variables, so that we can distinguish HSE+ channel variables from simply a program's internal variables.
Thus, we differentiate variables $V$ into ordinary variables $a$, channel acknowledge variables $A_a$, and channel data variables $A_t$ and $A_f$ for true and false, respectively.
We also need to pick an active end and a passive end for each channel in order to translate into HSE+.
We decide which end of the channel (the sending end or the receiving end) should be active using static analysis, and denote by $\rho \vDash A!$ the channel $A$ having its sending end active, and $\rho \vDash A?$ the channel $A$ having its receiving end active.
For simplicity, we restrict all channels to be 1-bit channels.
We also enforce channel end-to-endness and decide the scope of channels (i.e. minimum enclosing scope outside of which no process ever performs a send or receive on that channel).
We mark the scope for channel $A$ using $[P]_A$.

\subsection{Translation}
\begin{align*}
    \overline{A} & \Rightarrow \left\{ \begin{matrix} A_t \vee A_f & \qquad \rho \vDash A! \\ A_a & \qquad \rho \vDash A? \end{matrix} \right. \\
    A!\mathrm{b} & \Rightarrow \left\{ \begin{matrix} \{[\mathrm{b} \rightarrow A_t := \top \talloblong \neg \mathrm{b} \rightarrow A_f := \top]; [A_a]; A_t := \bot; A_f := \bot; [\neg A_a]\} & \qquad \rho \vDash A! \\
                                                      \{[A_a]; [\mathrm{b} \rightarrow A_t := \top \talloblong \neg \mathrm{b} \rightarrow A_f := \top]; [\neg A_a]; A_t := \bot; A_f := \bot\} & \qquad \rho \vDash A? \end{matrix} \right. \\
    A?a & \Rightarrow \left\{ \begin{matrix} \{[A_t \vee A_f]; a := A_t; A_a := \top; [\neg A_t \wedge \neg A_f]; A_a := \bot\} & \qquad \rho \vDash A! \\
                                             \{A_a := \top; [A_t \vee A_f]; a := A_t; A_a := \bot; [\neg A_t \wedge \neg A_f]\} & \qquad \rho \vDash A? \end{matrix} \right. \\
    C_1 \bullet C_2 & \Rightarrow \text{TODO}
\end{align*}

We will use $\{A!\mathrm{b}\}$ and $\{A?a\}$ as shorthand for either translation of $A!\mathrm{b}$ and $A?a$, respectively.

\section{LTS Semantics}
$$
    % skip, assign, sequential and parallel composition rules
    \frac{\langle P, \sigma \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle}{\langle P ; Q, \sigma \rangle \xrightarrow{\delta} \langle P' ; Q, \sigma' \rangle} \qquad
    \frac{\langle P, \sigma \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\delta} \langle P' || Q, \sigma' \rangle} \qquad
    \frac{\langle Q, \sigma \rangle \xrightarrow{\delta} \langle Q', \sigma' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\delta} \langle P || Q', \sigma' \rangle} \qquad
    \frac{}{\langle \mathtt{skip}; P, \sigma \rangle \xrightarrow{\tau} \langle P, \sigma \rangle} $$$$
    \frac{\sigma \models \mathrm{b} = \ell}{\langle a := \mathrm{b}, \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip}, \sigma[a = \ell] \rangle} \qquad
    \frac{}{\langle \mathtt{skip} || P, \sigma \rangle \xrightarrow{\tau} \langle P, \sigma \rangle} \qquad
    \frac{}{\langle P || \mathtt{skip}, \sigma \rangle \xrightarrow{\tau} \langle P, \sigma \rangle} $$$$
    % selection rules
    \frac{\sigma \models \mathrm{b}_1 = \bot \wedge \; \ldots \; \wedge \; \mathrm{b}_{i-1} = \bot \; \wedge \mathrm{b}_i = \top \wedge \mathrm{b}_{i+1} = \bot \wedge \; \ldots \; \wedge \; \mathrm{b}_n = \bot} {\langle [ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i , \sigma\rangle  } \qquad
    \frac{\sigma \models \mathrm{b}_i = \top} {\langle [ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i , \sigma\rangle  } $$$$
    \frac{\sigma \models b_1 = \bot \wedge \ldots \wedge b_n = \bot}{\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip} , \sigma\rangle } \qquad
    \frac{\sigma \models b_1 = \bot \wedge \ldots \wedge b_n = \bot}{\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle \mathtt{skip} , \sigma \rangle } $$$$
%   \frac{\langle S, \sigma \rangle \xrightarrow{\tau} \langle P, \sigma \rangle}{\langle *S, \sigma \rangle \xrightarrow{\tau} \langle P;*S, \sigma \rangle} $$$$
    \frac{\sigma \models \mathrm{b}_1 = \bot \wedge \; \ldots \; \wedge \; \mathrm{b}_{i-1} = \bot \wedge \mathrm{b}_i = \top \wedge \mathrm{b}_{i+1} = \bot \wedge \; \ldots \; \wedge \; \mathrm{b}_n = \bot} {\langle *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i; \; *[ \mathrm{b}_1 \rightarrow P_1  \talloblong \; \ldots \; \talloblong \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  } $$$$
    \frac{\sigma \models \mathrm{b}_i = \top} {\langle *[ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma \rangle \xrightarrow{\tau} \langle P_i;\;*[ \mathrm{b}_1 \rightarrow P_1  | \; \ldots \; | \mathrm{b}_n \rightarrow P_n ] , \sigma\rangle  } $$$$
    % communication rules
    \frac{\langle P, \sigma \rangle \xrightarrow{\delta} \langle P', \sigma' \rangle \quad A!\ell \not \in \delta \quad A?a:\ell \not \in \delta}{\langle [P]_A, \sigma \rangle \xrightarrow{\delta} \langle [P']_A, \sigma' \rangle} $$$$
    \frac{\sigma \models \mathrm{b} = \top}{\langle \{A!\mathrm{b}\}, \sigma \rangle \xrightarrow{A!\top} \langle \mathtt{skip}, \sigma[A_t = \top, A_a = \top] \rangle} \qquad
    \frac{\sigma \models \mathrm{b} = \bot}{\langle \{A!\mathrm{b}\}, \sigma \rangle \xrightarrow{A!\bot} \langle \mathtt{skip}, \sigma[A_f = \top, A_a = \top] \rangle} $$$$
    \frac{}{\langle \{A?a\}, \sigma \rangle \xrightarrow{A?a : \top} \langle \mathtt{skip}, \sigma[A_t = \top, A_a = \top, a = \top] \rangle} \qquad
    \frac{}{\langle \{A?a\}, \sigma \rangle \xrightarrow{A?a : \bot} \langle \mathtt{skip}, \sigma[A_f = \top, A_a = \top, a = \bot] \rangle} $$$$
    \frac{\langle P, \sigma \rangle \xrightarrow{A!\ell} \langle P', \sigma' \rangle \quad \langle Q, \sigma \rangle \xrightarrow {A?a : \ell} \langle Q', \sigma'' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\tau} \langle P' || Q', \sigma[a = \ell] \rangle} \qquad
    \frac{\langle P, \sigma \rangle \xrightarrow{A?a : \ell} \langle P', \sigma' \rangle \quad \langle Q, \sigma \rangle \xrightarrow {A!\ell} \langle Q', \sigma'' \rangle}{\langle P || Q, \sigma \rangle \xrightarrow{\tau} \langle P' || Q', \sigma[a = \ell] \rangle}
    % bullet rules
    $$$$ \text{TODO bullet rules here}
$$

$\sigma$ is the environment, which in this case consists of a set of mappings of variables to values.
We initialize $\sigma$ to include $A_a = \bot$, $A_t = \bot$, $A_f = \bot$ for all channels $A$.
Furthermore, note that the labels on the transitions are sets, since we can have several channel operations occurring at once (via $\bullet$).

TODO: probes are currently broken, and will always evaluate to false (since they are only `true' when the other process has performed a labeled transition, but before the react rule takes place; we can never actually be in this state. Should we use the old $\rho$ method to make probes work again?)

\end{document}
